import threadingimport uuidG_LEN_DRIVER_EVQ = 5000G_LEN_FW_EVQ = 80G_LEN_CLIENT_EVQ = 100G_LEN_BIF_EVQ = 100###################################### Event Queue ################################################# Event-queue content itemclass EVQItem(object):    def __init__(me):        me.next=None    # Link to next item        me.content=None # Item content # Exception define for Event-queueclass EVQExcption(Exception):    def __init__(me,obj):        me.body=obj    def __str__(me):        return "EVQ Exception : %s" % repr(me.body)# Asynchronization read-write Event-queueclass commonEVQ(object):    def __init__(me,length=100):        if length<5: raise EVQExcption("Initialize length too short")        tail=me.__wrt=me.__rd=EVQItem()        me.maxitem=length # Max length        while length:            tail.next=EVQItem()            tail=tail.next            length-=1        tail.next=me.__wrt #Loop back        me.__rhook={}        me.__whook={}        me.rcount=0     # count(read)        me.wcount=0     # count(write)        me.fcount=0     # count(full)    def read(me,length=1):        if me.__rd != me.__wrt:            result=[]            while me.__rd != me.__wrt:                result.append(me.__rd.content)                me.__rd.content=None                me.__rd=me.__rd.next                me.rcount+=1                if length and len(result)>=length:return result            if me.__rhook:                for uid,exc in me.__rhook.items(): exc()            return result        else:            return []    def write(me,something):        if me.__wrt.next==me.__rd: return -1        count=0        for t in something:            me.__wrt.content=t            me.__wrt=me.__wrt.next            count+=1            me.wcount+=1            if me.__wrt.next==me.__rd:                me.fcount+=1                break        if me.__whook and count:                for uid,exc in me.__whook.items(): exc()        return count    # Hook process method in queue operation    def hook(me,opt,func):        uid=uuid.uuid4()        if opt=="read":            me.__rhook[uid.hex]=func        elif opt=="write":            me.__whook[uid.hex]=func        else: return None        return uid.hex    def unhook(me,uid):        if uid and uid in me.__rhook:            del me.__rhook[uid]        elif uid and uid in me.__whook:            del me.__whook[uid]    def getStatus(me):        return {"length":me.wcount-me.rcount,                "max":me.maxitem,                "read":me.rcount,                "write":me.wcount,                "overflow":me.fcount}###################################### Message Bus ################################################class BusItem(object):    def __init__(me,name,ItemQClient=None, ItemQFw=None):        global G_LEN_FW_EVQ        me.cVer=0   # Client write version        me.dVer=0   # Driver read version        me.cQueue=commonEVQ(ItemQClient or G_LEN_CLIENT_EVQ)    # Client receive queue        me.fQueue=commonEVQ(ItemQFw or G_LEN_FW_EVQ)            # Forward queue        me.fQLock=threading.Lock()  # Forward queue lock        me.enable=True  # Enable        me.name=name    @staticmethod    def updateVer(original_ver):        return (original_ver<1000000000 and (original_ver+1)) or 1# Event Busclass commonBusServer(object):    def __init__(me, ThreadQ=G_LEN_DRIVER_EVQ, ItemQClient=None, ItemQFw=None):        me.__finder={}                      # Member index        me.__sig=1                          # Exit signal (set 0 for exit)        me.__reglock=threading.Lock()       # Member index lock        me.__drsem=threading.Semaphore()    # Forward thread semaphore        me.__dQueue=[commonEVQ(ThreadQ)] # Forward threads buffer queue        me.__drivers=[threading.Thread(target=me.__driver,args=(me.__dQueue[0],))]# Forward threads        me.__ItemQueueConf=(ItemQClient,ItemQFw)        for drv in me.__drivers: drv.start()    # Regist new member    # return (Send function , Recive queue)    def regMember(me,name,ItemQClient=None,ItemQFw=None):        def closureSender(itm):            def Sender(targetnames,something):                if not itm.enable: return -1                if type(targetnames)==str: # One target                    names=[targetnames]                elif targetnames==None: # Broadcast                    me.__reglock.acquire()                    names=[k for k,bitm in me.__finder.items()]                    me.__reglock.release()                else: # Multi-target                    names=targetnames                result=[]                itm.fQLock.acquire()                for pn in names:                    if pn == itm.name:continue                    if itm.fQueue.write([(pn,something)]):                        result.append(pn)                if result: itm.cVer=BusItem.updateVer(itm.cVer)                itm.fQLock.release()                me.__releaseDriver()                return result            return Sender        if not ItemQClient: ItemQClient = me.__ItemQueueConf[0]        if not ItemQFw: ItemQFw = me.__ItemQueueConf[1]        me.__reglock.acquire()        try:            if name in me.__finder: return None            tmpitm=me.__finder[name]=BusItem(name,ItemQClient,ItemQFw)            return (closureSender(tmpitm),tmpitm.cQueue)        finally:            me.__reglock.release()    # Unregist member    def unreg(me,name):        me.__reglock.acquire()        if name in me.__finder:            me.__finder[name].enable=False            del me.__finder[name]        me.__reglock.release()    def items(me):        return [k for k in me.__finder.keys()]    def terminate(me):        me.__sig=0    def getStatus(me):        me.__reglock.acquire()        try:            return {                "drivers":[d.getStatus() for d in me.__dQueue],                "members":{                    nm:{"client":itm.cQueue.getStatus(),                        "forward":itm.fQueue.getStatus()} for nm,itm in me.__finder.items()}                }        finally:            me.__reglock.release()    # Release Semaphore for forward-thread    def __releaseDriver(me):        me.__drsem.release()    # Forward-thread    def __driver(me,drvQueue):        global G_LEN_DRIVER_EVQ        print("[MsgBus]Message bus driver start!")        while me.__sig:            me.__drsem.acquire(timeout=2)            me.__reglock.acquire()            for memb in me.__finder.items():                if (memb[1].cVer != memb[1].dVer):                    memb[1].dVer=memb[1].cVer                    drvQueue.write(memb[1].fQueue.read(0))            sendBlock=[]            for senditm in drvQueue.read(0):                if senditm[0] in me.__finder:                    count=me.__finder[senditm[0]].cQueue.write(senditm[1])                    if count<0:                        sendBlock.append(senditm)                    elif count < len(senditm[1]):                        sendBlock.append((senditm[0],senditm[1][count:]))            me.__reglock.release()            drvQueue.write(sendBlock)        print("[MsgBus]Message bus driver exit!")##################################### Interface template ########################################### Basic interfaceclass baseIF(object):    def __init__(me,name=uuid.uuid4().hex,inputQ=None,*arglist,**argdict):        me.__busName=name                   # Module name for bus regist        me.__inputQueue=commonEVQ(inputQ or G_LEN_BIF_EVQ)         # Input message queue        me.__inputLock=threading.Lock()     # Input lock        me.__busGrp={}                      # All registed bus        me.__busGrpLock=threading.Lock()    # Write-lock of __busGrp        me.__outputGrp={}                   # All output target        me.__outputGrpLock=threading.Lock() # Write-lock of __outputGrp        me.__rsem=threading.Semaphore()     # Receive thread semaphore        me.__sig=1                          # Exit signal (set 0 for exit)        me.__sendcount=0                    # count(send)        me.__msgerror=0                     # count(process error)        me.__inputQueue.hook("write",me.__releaseRecv)        me._init(argdict,arglist)        threading.Thread(target=me.__receiver).start()    # Custom initialize method, you need override it    def _init(me,argdict,arglist):pass    # Regist bus in interface    def regBus(me,bus):        uid=uuid.uuid4().hex        me.__busGrpLock.acquire()        try:            memberObj=bus.regMember(me.__busName)            if memberObj:                me.__busGrp[uid]=memberObj                memberObj[1].hook("write",me.__releaseRecv)                return uid            else: return None        finally:            me.__busGrpLock.release()    # Unregist bus from interface    def unregBus(me,uid):        me.__busGrpLock.acquire()        try:            if uid in me.__busGrp:                del me.__busGrp[uid]                if uid in me.__outputGrp: me.rmOutput(uid)                return 0            return -1        finally:            me.__busGrpLock.release()    # Set output target    def setOutput(me,target,busnames=None):        def buswriter(buswf,name):            def wf(datas): return buswf(name,datas)            return wf        def ifcwriter(ifc):            def wf(datas): return ifc.getInput()(datas)            return wf        uid=uuid.uuid4().hex        lkbus=False        if type(target)==str:            me.__busGrpLock.acquire()            lkbus=True        me.__outputGrpLock.acquire()        try:            if isinstance(target,baseIF):                me.__outputGrp[uid]=ifcwriter(target)                return uid            elif type(target)==str and target in me.__busGrp:                #if target in me.__outputGrp: return target                me.__outputGrp[target]=buswriter(me.__busGrp[target][0],busnames)                return target            else:                return None        finally:            me.__outputGrpLock.release()            if lkbus: me.__busGrpLock.release()    # Remove output target    def rmOutput(me,uid):        me.__outputGrpLock.acquire()        try:            if uid in me.__outputGrp:                del me.__outputGrp[uid]                return 0            else:                return -1        finally:            me.__outputGrpLock.release()    # Get module input method    def getInput(me):        def writer(datas):            me.__inputLock.acquire()            try:                me.__inputQueue.write(datas)            finally:                me.__inputLock.release()        return writer    # Send data to output interface    def _send(me,datas):        me.__outputGrpLock.acquire()        outlist=[out for k,out in me.__outputGrp.items()]        me.__outputGrpLock.release()        for out in outlist: out(datas)        me.__sendcount+=1    # Message process method, you need override it    def _msg(me,data,source):        print("Module '%s' get message from %s > %s" % (me.__busName,repr(source),repr(data)))    def terminate(me):        me.__sig=0    def getStatus(me):        return {"name":me.__busName,                "input":me.__inputQueue.getStatus(),                "output":me.__sendcount,                "output_target":[nm for nm in me.__outputGrp.keys()],                "bus":[nm for nm in me.__busGrp.keys()],                "error":me.__msgerror}    # Release receiver thread semaphore    def __releaseRecv(me):        me.__rsem.release()    # Message receiver thread    def __receiver(me):        def tryexec(data,source):            try:                me._msg(data,source)            except Exception as e:                print("Thread Error : %s" % str(e))                me.__msgerror+=1        print("[Server]Module '%s' start!" % me.__busName)        while me.__sig:            me.__rsem.acquire(timeout=2)            rv=me.__inputQueue.read(0)            if rv:                for data in rv:                    tryexec(data,None)            me.__busGrpLock.acquire()            binput=[(busop[1].read(0),k) for k,busop in me.__busGrp.items()]            me.__busGrpLock.release()            for brv in binput:                if brv[0]:                    for data in brv[0]:                        tryexec(data,brv[1])        print("[Server]Module '%s' exit!" % me.__busName)######################################## Line processor ############################################ Line method serverclass SvrLine(baseIF):    # Method item    class lineItem(object):        def __init__(me,func):            me.next=None            me.prev=None            me.func=func            me.uuid=uuid.uuid4().hex    def _init(me,argdict,arglist):        me.__fhead=me.lineItem(None)    # Head of link        me.__ftail=None                 # Tail of link        me.__ftab={}                    # Method table        me.__changeLock=threading.Lock()    # Method change lock    def _msg(me,data,source):        me.__changeLock.acquire()        try:            method=me.__fhead.next            while method:                data,exit=method.func(data,source)                if exit:return                method=method.next            me._send([data])        finally:            me.__changeLock.release()    # Append method    def append(me,func):        me.__changeLock.acquire()        fitem=me.lineItem(func)        me.__ftab[fitem.uuid]=fitem        if me.__ftail:            fitem.prev=me.__ftail            me.__ftail.next=fitem        else:            fitem.prev=me.__fhead            me.__fhead.next=fitem        me.__ftail=fitem        me.__changeLock.release()        return fitem.uuid    # Method insert befor specify position    def insert(me,uid,func):        me.__changeLock.acquire()        try:            if uid in me.__ftab:                fitem=me.lineItem(func)                me.__ftab[fitem.uuid]=fitem                fitem.prev=me.__ftab[uid].prev                me.__ftab[uid].prev.next=fitem                me.__ftab[uid].prev=fitem                fitem.next=me.__ftab[uid]                return fitem.uuid            else:                return None        finally:            me.__changeLock.release()    # Remove method    def remove(me,uid):        me.__changeLock.acquire()        if uid in me.__ftab:            me.__ftab[uid].prev.next=me.__ftab[uid].next            if me.__ftab[uid].next: me.__ftab[uid].next.prev=me.__ftab[uid].prev            del me.__ftab[uid]        me.__changeLock.release()