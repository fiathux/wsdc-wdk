import rep_commentln = re.compile("^#.*$")p_comment = re.compile("\s+#.*$")p_chunk = re.compile("^([a-zA-Z][a-zA-Z0-9_]*)\\s*{$")p_kv = re.compile("^([a-zA-Z][a-zA-Z0-9_]*)\\s*=\\s*(.*)")def confFactory(**arg):    class confObj(object): # Configure object prototype        def __init__(I,initobj={}):            I.__mem = {k:(confObj(itm) if type(itm) == dict else itm) for k,itm in initobj.items()}            I.__dict__.update(I.__mem)        def __str__(I):            shift = lambda s: s.replace("\\","\\\\").replace("\n","\\n").replace(" ","\\_").\                    replace("\t","\\t").replace("#","\\#")            return "\n".join([(" %s = %s" % (dk,shift(dv)) if type(dv) == str else\                    "%s {\n%s\n}" % (dk,str(dv))) for dk,dv in I.__mem.items()])        def __call__(I):            return {mk: (mv() if isinstance(mv,confObj) else mv) \                    for mk,mv in I.__mem.items()}        def __getitem__(I,name): return I.__mem[name]        def __setitem__(I,name,value):            if name in I.__mem: I.__mem[name]=value        def __contains__(I,name): return name in I.__mem        def __iter__(I): return map(lambda itm:(itm[0],itm[1]), I.__mem.items())    def confLine(lines): # Configure's text-lines parser        def parseValue(vstr):            if not vstr: return ("",False)            vgrp=vstr.split("\\\\")            mt = vgrp and vgrp[-1] and vgrp[-1][-1] and vgrp[-1][-1]=="\\"            if mt: vgrp[-1] = vgrp[-1][:-1]            return ("\\".join([per.replace("\\n","\n").replace("\\t","\t").replace("\\_"," ").\                    replace("\\#","#") for per in vgrp]),mt)        result={}        stack=[]        cur=result        dataline=None        for ln in lines:            sln=ln.strip()            if (not sln) or p_commentln.search(sln): continue            pcmt=p_comment.search(sln)            if pcmt: sln = sln[:pcmt.start()]            if not dataline: # New define line                if sln=="}" and stack:                    cur=stack.pop()                    continue                pchnk=p_chunk.match(sln)                if pchnk:                    stack.append(cur)                    cur[pchnk.group(1)]={}                    cur=cur[pchnk.group(1)]                    continue                pkv=p_kv.match(sln)                if pkv:                    dstr,mtline = parseValue(pkv.group(2))                    if mtline:                        dataline=(pkv.group(1),[dstr])                    else:                        cur[pkv.group(1)]=dstr            else: # Multi-line                dstr,mtline = parseValue(sln)                dataline[1].append(dstr)                if not mtline:                    cur[dataline[0]]="\n".join(dataline[1])                    dataline=None        return result    cset=("enc" in arg and arg["enc"]) or "utf-8"    confstr = (("file" in arg) and open(arg["file"],"r",-1,cset).read()) or\            ("str" in arg and arg["str"]) or ""    conflines = confstr.split("\n")    return confObj(confLine(conflines))