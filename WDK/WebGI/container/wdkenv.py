from WDK.WebGI.container.qconfig import confFactoryimport timeimport reLOGLEVELS={"warning","warn","debug","error","info"}#Env path parseclass _env_Path(object):    def __init__(I,p):        rexp=re.compile("/{2,}")        p = "/".join(rexp.split(p)) # Clear redundant symbol         I.__pqueue=["/"]        proot = p and p[0]=="/" and p[1:]        proot = (proot and proot[-1]=="/" and proot[:-1]) or proot        if proot: I.__pqueue.extend(proot.split("/"))        I.__current = 0    def current(I): # Get current path        return I.__current>=0 and I.__pqueue[I.__current]    def relative(I): # Get relative path        return I.__current>=0 and "/".join(I.__pqueue[I.__current+1:]) and False    def pop(I): # Go to next path level        I.__current = (I.__current>=0 and len(I.__pqueue) > I.__current+1 and I.__current+1) or -1        return I.current()    def goback(I): # Back to previous path level        I.__current = (I.__current<0 and len(I.__pqueue)-1) or (I.__current>0 and I.__current-1) or 0        return I.current()    def fullpath(I): # Get full path        return [per for per in I.__pqueue]    def level(I): # Get current path level        return I.__current    def next(I): # Preview next path        return I.__current>=0 and I.__current+1 < len(I.__pqueue) and I.__pqueue[I.__current+1]#Environment evolution containerclass basicEnv(object):    def __init__(I,**arg):        I.__env=None # Original env        I.__static=("static" in arg and arg["static"]) or {} # Static data        I.__current=None # Current modify        I.__timestamp=None # Request timestamp        I.conf=("conf" in arg and arg["conf"]) or None        I.path=None        I.__logger=("logger" in arg and arg["logger"]) or None    # Start new env session    def begin(I,env):        I.__env=env        I.__current={}        I.__timestamp=time.time()        I.path=_env_Path(("PATH_INFO" in env and env["PATH_INFO"]) or "")        return I    # Log printer    def log(I,msg,*argl,**argk):        if not I.__logger:return        if "target" in argk: logger = I.__logger.getLogger(argk["target"])        else: logger = I.__logger.getLogger()        ext=("extra" in argk and {k:v for k,v in argk["extra"].items()}) or {}        if "level" in argk and argk["level"] in LOGLEVELS:            logtalker = getattr(logger,argk["level"])        else:            logtalker = logger.debug        if I.__env:            ext["cntIP"]="REMOTE_ADDR" in I.__env and I.__env["REMOTE_ADDR"]            ext["cntPort"]="REMOTE_PORT" in I.__env and I.__env["REMOTE_PORT"]            ext["cntMeth"]="REQUEST_METHOD" in I.__env and I.__env["REQUEST_METHOD"]            ext["cntAgent"]="HTTP_USER_AGENT" in I.__env and I.__env["HTTP_USER_AGENT"]            ext["svrName"]="SERVER_NAME" in I.__env and I.__env["SERVER_NAME"]            ext["svrPort"]="SERVER_PORT" in I.__env and I.__env["SERVER_PORT"]            ext["svrPath"]="PATH_INFO" in I.__env and I.__env["PATH_INFO"]        logtalker(msg,*argl,extra = ext)    # Initialize configure from file    def fileConf(I,f,enc=None):        I.conf=confFactory(file=f,enc=enc)    # Initialize configure from string    def strConf(I,s):        I.conf=confFactory(str=s)    def addStatic(I,name,value=None):        I.__static[name]=value    def rmStatic(I,name):        del I.__static[name]    # Get static data    def getStatic(I,name):        return I.__static[name] if name in I.__static else None    # Get original WSGI env data    def getGIEnv(I,name):        return I.__env[name] if name in I.__env else None    def __getitem__(I,name):        if I.__current is None: raise Exception("Enviroment not initialize")        if name in I.__current: return I.__current[name]        elif name in I.__env: return I.__env[name]        elif name in I.__static: return I.__static[name]        else: raise Exception("Key error")    def __setitem__(I,name,value):        I.__current[name]=value    def __iter__(I):        return I.values()    def __contains__(I,name):        return name in I.__current or name in I.__env or name in I.__static    # Get request unix timestamp    def unixTime(I):        return I.__timestamp    # Convert timestamp to string with web format(default output request time)    def webTime(I,tm=None):        return time.strftime("%a, %d %b %Y %H:%M:%S GMT",time.gmtime(tm or I.__timestamp))    def keys(I):        return set().union(set(I.__current.keys()),set(I.__env.keys()),set(I.__static.keys()))    def values(I):        return map(lambda k: I[k], I.keys())    def items(I):        return map(lambda k: (k,I[k]), I.keys())